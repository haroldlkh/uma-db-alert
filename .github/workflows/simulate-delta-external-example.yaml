name: Simulate UMA Delta (test external repo)

on:
  workflow_dispatch:
    inputs:
      environment_name:
        description: "Env label used for state (external repos usually use 'repo')"
        type: string
        default: repo
      simulate_search:
        description: "Exact search name to target (blank = first search)"
        type: string
        required: false
      simulate_count:
        description: "How many IDs to re-emit for that search"
        type: number
        default: 1

jobs:
  simulate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Resolve state dir (per repo + environment)
        id: st
        shell: bash
        run: |
          REPO_NS="${GITHUB_REPOSITORY//\//_}"
          ENV_NAME="${{ inputs.environment_name }}"
          DIR="$HOME/.uma_monitor/$REPO_NS/$ENV_NAME"
          echo "dir=$DIR" >> "$GITHUB_OUTPUT"
          mkdir -p "$DIR"

      - name: Restore state cache
        uses: actions/cache/restore@v4
        with:
          path: ${{ steps.st.outputs.dir }}
          key: uma-state-${{ github.repository }}-${{ inputs.environment_name }}-v1-${{ github.run_id }}
          restore-keys: |
            uma-state-${{ github.repository }}-${{ inputs.environment_name }}-v1-
            uma-state-${{ github.repository }}--v1-

      - name: Match state namespace env
        run: |
          echo "UMA_ENV_NAME=${{ inputs.environment_name }}" >> $GITHUB_ENV
          echo "UMA_STATE_DIR=${{ steps.st.outputs.dir }}" >> $GITHUB_ENV

      - name: Install YAML dependency
        run: pip install pyyaml

      - name: Edit state to force N deltas
        run: |
          python - <<'PY'
          import os, json, yaml, glob, sys
          from urllib.parse import urlsplit, urlunsplit, parse_qsl, urlencode

          def canon_url(u: str) -> str:
              u = (u or "").strip()
              if not u: return ""
              try:
                  scheme, netloc, path, query, frag = urlsplit(u)
                  scheme = (scheme or "").lower()
                  netloc = (netloc or "").lower()
                  if path.endswith("/") and len(path) > 1:
                      path = path[:-1]
                  if query:
                      q = parse_qsl(query, keep_blank_values=True); q.sort()
                      query = urlencode(q)
                  return urlunsplit((scheme, netloc, path, query, ""))
              except Exception:
                  return u.rstrip("/")

          env  = os.environ["UMA_ENV_NAME"]
          root = os.environ["UMA_STATE_DIR"]           # base; actual files are under root/state
          state_dir = os.path.join(root, "state")

          cfg = yaml.safe_load(open("config/sites.yaml","r",encoding="utf-8")) or {}
          sites = cfg.get("sites") or []
          if not sites: sys.exit("No sites configured.")
          site = sites[0]
          src  = site["source_site"]
          searches = site.get("searches") or []
          if not searches: sys.exit("No searches configured.")

          want = (os.environ.get("SIM_SEARCH") or "").strip()
          names = [s.get("name") or f"search{i+1}" for i,s in enumerate(searches)]
          if want:
              try: idx = names.index(want)
              except ValueError: sys.exit(f"Search name '{want}' not found. Available: {', '.join(names)}")
          else:
              idx = 0

          s     = searches[idx]
          url   = s["url"]
          sname = s.get("name") or f"search{idx+1}"

          # Support both identity schemes
          per_search_site_id = f"{src}::{sname}"
          c_url              = canon_url(url)
          composite_key      = f"{c_url}||search={sname}"

          files = sorted(glob.glob(os.path.join(state_dir, "*.json")))
          if not files:
              sys.exit("No state files found yet. Run the monitor once to seed, then re-run this simulation.")

          picked = None
          reason = ""

          # 1) Old per-search scheme
          for f in files:
              try: d = json.load(open(f,"r",encoding="utf-8"))
              except Exception: continue
              if d.get("site_id") == per_search_site_id and d.get("search_url") == c_url:
                  picked, reason = (f, d), "per-search match"; break

          # 2) New composite scheme
          if not picked:
              for f in files:
                  try: d = json.load(open(f,"r",encoding="utf-8"))
                  except Exception: continue
                  if d.get("site_id") == src and d.get("search_url") == composite_key:
                      picked, reason = (f, d), "composite match"; break

          # 3) Fallback: name heuristic
          if not picked:
              for f in files:
                  try: d = json.load(open(f,"r",encoding="utf-8"))
                  except Exception: continue
                  if sname in (d.get("site_id","")) or sname in (d.get("search_url","")):
                      picked, reason = (f, d), "heuristic(name)"; break

          if not picked:
              sys.exit(f"No seeded state found for '{sname}'. Run the monitor once, then re-run this sim.")

          path, data = picked
          digs = data.get("digests") or {}
          ids  = sorted(digs.keys())
          if not ids:
              sys.exit(f"State has no digests yet for '{sname}' (not seeded?)")

          n = max(0, int(os.environ.get("SIM_COUNT","1")))
          victims = ids[:n]
          for vid in victims:
              digs.pop(vid, None)
          data["digests"] = digs
          with open(path,"w",encoding="utf-8") as g:
              json.dump(data, g, ensure_ascii=False, indent=2)
          print(f"[simulate] env={env} search={sname} reason={reason} file={os.path.basename(path)} removed_ids={victims}")
          PY
        env:
          SIM_SEARCH: ${{ inputs.simulate_search }}
          SIM_COUNT:  ${{ inputs.simulate_count }}

      - name: Save state cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: ${{ steps.st.outputs.dir }}
          key: uma-state-${{ github.repository }}-${{ inputs.environment_name }}-v1-${{ github.run_id }}
